use ark_ff::{FftField, Field};

use super::utils::{
    compute_per_polynomial_claims, construct_batched_eq_weights, BlindingEvaluations,
};
use super::Config;
use crate::{
    algebra::{
        dot,
        embedding::Embedding,
        polynomials::{CoefficientList, MultilinearPoint},
        Weights,
    },
    hash::Hash,
    protocols::{geometric_challenge::geometric_challenge, irs_commit, whir::Commitment},
    transcript::{
        codecs::U64, Codec, Decoding, DuplexSpongeInterface, ProverMessage, VerificationResult,
        VerifierMessage, VerifierState,
    },
    utils::zip_strict,
    verify,
};

/// ZK challenges sampled during verification.
///
/// Groups the challenge scalars that are threaded through multiple verifier
/// helper methods, reducing per-method parameter counts.
struct ZkChallenges<F> {
    /// Challenge used for blinding: g(X) = g₀(X) + Σᵢ blinding^i · X^(2^(i-1)) · ĝᵢ(X)
    blinding: F,
    /// Challenge used for masking: P = masking · f + g
    masking: F,
    /// RLC coefficients combining multiple committed polynomials
    polynomial_rlc_coeffs: Vec<F>,
}

impl<F: FftField> Config<F> {
    /// Verify a ZK WHIR opening proof.
    ///
    /// This verifies a proof generated by `prove`. The verifier:
    /// 1. Reads blinding evaluations g(āᵢ) and reconstructs modified sums
    /// 2. Runs WHIR rounds, reconstructing virtual oracle values at each initial opening
    /// 3. Verifies blinding polynomial evaluations via a nested WHIR proof
    /// 4. Checks the final sumcheck equation
    pub fn verify<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        commitment: &super::Commitment<F>,
        weights: &[&Weights<F>],
        evaluations: &[F],
    ) -> VerificationResult<(MultilinearPoint<F>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        // ====================================================================
        // Phase 1: ZK transcript header — read blinding challenges and build
        //          modified evaluations for P = masking·f + g
        // ====================================================================
        let f_hat_commitments = commitment.f_hat_commitments();
        let blinding_commitment = commitment.blinding_commitment();
        let num_polys = f_hat_commitments.len();
        let (blinding_challenge, masking_challenge, modified_evaluations) =
            self.read_header(verifier_state, weights, evaluations, num_polys)?;

        let polynomial_rlc_coeffs: Vec<F> =
            geometric_challenge(verifier_state, f_hat_commitments.len());
        let zk_challenges = ZkChallenges {
            blinding: blinding_challenge,
            masking: masking_challenge,
            polynomial_rlc_coeffs,
        };
        let constraint_rlc_coeffs: Vec<F> = geometric_challenge(verifier_state, weights.len());
        let mut round_constraints: Vec<(Vec<F>, Vec<Weights<F>>)> = vec![(
            constraint_rlc_coeffs.clone(),
            weights.iter().map(|&weight| weight.clone()).collect(),
        )];

        let mut the_sum: F = zip_strict(
            &constraint_rlc_coeffs,
            modified_evaluations.chunks_exact(num_polys),
        )
        .map(|(weight_coeff, row)| *weight_coeff * dot(&zk_challenges.polynomial_rlc_coeffs, row))
        .sum();

        let mut round_folding_randomness = Vec::new();

        let folding_randomness = if constraint_rlc_coeffs.is_empty() {
            assert_eq!(the_sum, F::ZERO);
            let fr = verifier_state
                .verifier_message_vec(self.blinded_commitment.initial_sumcheck.num_rounds);
            self.blinded_commitment
                .initial_sumcheck
                .round_pow
                .verify(verifier_state)?;
            MultilinearPoint(fr)
        } else {
            self.blinded_commitment
                .initial_sumcheck
                .verify(verifier_state, &mut the_sum)?
        };
        round_folding_randomness.push(folding_randomness);

        // ====================================================================
        // Phase 2: WHIR round loop
        // ====================================================================
        let mut prev_is_initial = true;
        let mut prev_round_commitment: Option<irs_commit::Commitment<F>> = None;

        for (round_index, round_config) in self.blinded_commitment.round_configs.iter().enumerate()
        {
            let commitment = round_config
                .irs_committer
                .receive_commitment(verifier_state)?;
            round_config.pow.verify(verifier_state)?;

            let num_variables = round_config.initial_num_variables();

            let (stir_weights, stir_values) = if prev_is_initial {
                self.verify_initial_round(
                    verifier_state,
                    &f_hat_commitments,
                    blinding_commitment,
                    &zk_challenges,
                    &commitment,
                    &round_folding_randomness,
                    num_variables,
                )?
            } else {
                self.verify_subsequent_round(
                    verifier_state,
                    round_index,
                    prev_round_commitment.as_ref().unwrap(),
                    &commitment,
                    &round_folding_randomness,
                    num_variables,
                )?
            };

            let stir_rlc_coeffs = geometric_challenge(verifier_state, stir_weights.len());
            the_sum += dot(&stir_rlc_coeffs, &stir_values);
            round_constraints.push((stir_rlc_coeffs, stir_weights));

            let folding_randomness = round_config.sumcheck.verify(verifier_state, &mut the_sum)?;
            round_folding_randomness.push(folding_randomness);

            prev_is_initial = false;
            prev_round_commitment = Some(commitment);
        }

        // ====================================================================
        // Phase 3: Final round — read polynomial, verify last commitment
        // ====================================================================
        let final_coefficients = CoefficientList::new(
            verifier_state
                .prover_messages_vec(self.blinded_commitment.final_sumcheck.initial_size)?,
        );
        self.blinded_commitment.final_pow.verify(verifier_state)?;

        self.verify_final_opening(
            verifier_state,
            prev_is_initial,
            &f_hat_commitments,
            blinding_commitment,
            &zk_challenges,
            prev_round_commitment.as_ref(),
            &round_folding_randomness,
            &final_coefficients,
        )?;

        // ====================================================================
        // Phase 4: Final sumcheck + consistency check
        // ====================================================================
        let final_sumcheck_randomness = self
            .blinded_commitment
            .final_sumcheck
            .verify(verifier_state, &mut the_sum)?;
        round_folding_randomness.push(final_sumcheck_randomness.clone());

        let result = self.verify_final_consistency(
            verifier_state,
            &round_constraints,
            &round_folding_randomness,
            &final_coefficients,
            &final_sumcheck_randomness,
            the_sum,
        );

        result
    }

    /// Read the ZK transcript header: blinding challenge, g(āᵢ) evaluations, masking challenge.
    ///
    /// Returns `(blinding_challenge, masking_challenge, modified_evaluations)` where
    /// modified_evaluations[i] = masking_challenge · evaluations[i] + g_evals[i].
    fn read_header<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        weights: &[&Weights<F>],
        evaluations: &[F],
        num_commitments: usize,
    ) -> VerificationResult<(F, F, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
    {
        let blinding_challenge: F = verifier_state.verifier_message();
        let g_evals: Vec<F> =
            verifier_state.prover_messages_vec(weights.len() * num_commitments)?;
        let masking_challenge: F = verifier_state.verifier_message();

        let modified_evaluations: Vec<F> = zip_strict(evaluations, &g_evals)
            .map(|(&eval, &g_eval)| masking_challenge * eval + g_eval)
            .collect();

        Ok((blinding_challenge, masking_challenge, modified_evaluations))
    }

    /// Open f̂ commitments and verify blinding evaluations, returning lifted
    /// in-domain evaluations and virtual oracle values.
    ///
    /// Shared by `verify_initial_round` (STIR constraint construction) and
    /// `verify_final_opening` (direct polynomial consistency check).
    fn open_and_verify_initial_blinding<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        f_hat_commitments: &[&Commitment<F>],
        blinding_commitment: &Commitment<F>,
        challenges: &ZkChallenges<F>,
        folding_randomness: &MultilinearPoint<F>,
    ) -> VerificationResult<(irs_commit::Evaluations<F>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let in_domain_base = self
            .blinded_commitment
            .initial_committer
            .verify(verifier_state, f_hat_commitments)?;

        let virtual_oracle_values = self.verify_blinding_evaluations(
            verifier_state,
            &in_domain_base,
            blinding_commitment,
            challenges,
            folding_randomness,
            f_hat_commitments.len(),
        )?;
        let in_domain = in_domain_base.lift(self.blinded_commitment.embedding());
        Ok((in_domain, virtual_oracle_values))
    }

    /// Verify the initial ZK round opening: verify f̂ commitment(s), blinding evaluations,
    /// and reconstruct virtual oracle values.
    ///
    /// For N committed polynomials, opens all N f̂ commitments, verifies blinding
    /// evaluations for each, and reconstructs combined virtual oracle values using
    /// the polynomial RLC coefficients.
    ///
    /// Returns `(stir_weights, stir_values)`.
    fn verify_initial_round<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        f_hat_commitments: &[&Commitment<F>],
        blinding_commitment: &Commitment<F>,
        challenges: &ZkChallenges<F>,
        commitment: &irs_commit::Commitment<F>,
        round_folding_randomness: &[MultilinearPoint<F>],
        num_variables: usize,
    ) -> VerificationResult<(Vec<Weights<F>>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let (in_domain, virtual_oracle_values) = self.open_and_verify_initial_blinding(
            verifier_state,
            f_hat_commitments,
            blinding_commitment,
            challenges,
            round_folding_randomness.last().unwrap(),
        )?;

        let stir_weights: Vec<Weights<F>> = commitment
            .out_of_domain()
            .weights(num_variables)
            .chain(in_domain.weights(num_variables))
            .collect();
        let stir_values: Vec<F> = commitment
            .out_of_domain()
            .values(&[F::ONE])
            .chain(virtual_oracle_values)
            .collect();

        Ok((stir_weights, stir_values))
    }

    /// Verify a subsequent (non-initial) round opening.
    ///
    /// Returns `(stir_weights, stir_values)`.
    fn verify_subsequent_round<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        round_index: usize,
        prev_commitment: &irs_commit::Commitment<F>,
        commitment: &irs_commit::Commitment<F>,
        round_folding_randomness: &[MultilinearPoint<F>],
        num_variables: usize,
    ) -> VerificationResult<(Vec<Weights<F>>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let prev_round_config = &self.blinded_commitment.round_configs[round_index - 1];
        let in_domain = prev_round_config
            .irs_committer
            .verify(verifier_state, &[prev_commitment])?;

        let stir_weights: Vec<Weights<F>> = commitment
            .out_of_domain()
            .weights(num_variables)
            .chain(in_domain.weights(num_variables))
            .collect();
        let stir_values: Vec<F> = commitment
            .out_of_domain()
            .values(&[F::ONE])
            .chain(in_domain.values(&round_folding_randomness.last().unwrap().coeff_weights(true)))
            .collect();

        Ok((stir_weights, stir_values))
    }

    /// Verify the final commitment opening.
    ///
    /// Handles both the case where this is the initial commitment (no intermediate
    /// rounds) and the case where it's the last WHIR round commitment.
    /// For the initial case with N polynomials, opens all N f̂ commitments and
    /// verifies the batched virtual oracle.
    fn verify_final_opening<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        prev_is_initial: bool,
        f_hat_commitments: &[&Commitment<F>],
        blinding_commitment: &Commitment<F>,
        challenges: &ZkChallenges<F>,
        prev_round_commitment: Option<&irs_commit::Commitment<F>>,
        round_folding_randomness: &[MultilinearPoint<F>],
        final_coefficients: &CoefficientList<F>,
    ) -> VerificationResult<()>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        if prev_is_initial {
            let (in_domain, virtual_oracle_values) = self.open_and_verify_initial_blinding(
                verifier_state,
                f_hat_commitments,
                blinding_commitment,
                challenges,
                round_folding_randomness.last().unwrap(),
            )?;

            for (weights, value) in zip_strict(
                in_domain.weights(final_coefficients.num_variables()),
                virtual_oracle_values,
            ) {
                verify!(weights.evaluate(final_coefficients) == value);
            }
        } else {
            let prev_round_config = self.blinded_commitment.round_configs.last().unwrap();
            let in_domain = prev_round_config
                .irs_committer
                .verify(verifier_state, &[prev_round_commitment.unwrap()])?;

            for (weights, evals) in zip_strict(
                in_domain.weights(final_coefficients.num_variables()),
                in_domain.values(&round_folding_randomness.last().unwrap().coeff_weights(true)),
            ) {
                verify!(weights.evaluate(final_coefficients) == evals);
            }
        }
        Ok(())
    }

    /// Verify the initial commitment opening: verify [[f̂]], read + verify blinding
    /// evaluations, and reconstruct virtual oracle constraint values.
    ///
    /// For N committed polynomials, reads N blinding evaluation sets per gamma point,
    /// verifies them via a nested WHIR proof, then reconstructs per-polynomial virtual
    /// oracle values L_p(γ) and combines them via polynomial RLC.
    ///
    /// Returns the virtual oracle folded values for each query point (to use as
    /// STIR in-domain constraint values).
    fn verify_blinding_evaluations<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        in_domain_base: &irs_commit::Evaluations<F::BasePrimeField>,
        blinding_commitment: &Commitment<F>,
        challenges: &ZkChallenges<F>,
        folding_randomness: &MultilinearPoint<F>,
        num_polys: usize,
    ) -> VerificationResult<Vec<F>>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        use crate::algebra::polynomials::fold::compute_fold;

        let embedding = self.blinded_commitment.embedding();
        let num_witness_vars = self.num_witness_variables();
        let interleaving_depth = self.interleaving_depth();
        let fold_factor = interleaving_depth.trailing_zeros() as usize; // log2(interleaving_depth)
        let omega_full = self.omega_full();
        let omega_powers = self.omega_powers();

        // Precompute inverses for compute_fold (lifted to extension field)
        let zeta_ext_inv: F = embedding
            .map(self.zeta())
            .inverse()
            .expect("coset generator invertible");
        let two_inv = F::from(2u64).inverse().expect("char ≠ 2");

        // Read ALL blinding evaluations from transcript in one batch.
        // Prover sends: for each gamma, for each polynomial:
        //   m_eval, ĝ₁(pow(γ)), ..., ĝμ(pow(γ))
        let num_query_points = in_domain_base.points.len();
        let evals_per_point = 1 + num_witness_vars; // m_eval + witness_vars g_hat_evals
        let num_gammas = num_query_points * interleaving_depth;
        let total_evals = num_gammas * num_polys * evals_per_point;
        let all_evals: Vec<F> = verifier_state.read_prover_messages_bytes(total_evals)?;

        // Parse the flat eval vector into per-polynomial BlindingEvaluations.
        let mut blinding_evals_per_poly: Vec<Vec<BlindingEvaluations<F>>> = (0..num_polys)
            .map(|_| Vec::with_capacity(num_gammas))
            .collect();
        let mut query_indices: Vec<usize> = Vec::with_capacity(num_query_points);
        let mut eval_cursor = 0;

        for &alpha_base in &in_domain_base.points {
            let domain_position = self.query_index(alpha_base, &omega_powers);
            query_indices.push(domain_position);
            let coset_gammas = self.coset_gammas(alpha_base, &omega_powers);

            for gamma in coset_gammas {
                for poly_idx in 0..num_polys {
                    let m_eval = all_evals[eval_cursor];
                    eval_cursor += 1;
                    let g_hat_evals =
                        all_evals[eval_cursor..eval_cursor + num_witness_vars].to_vec();
                    eval_cursor += num_witness_vars;
                    blinding_evals_per_poly[poly_idx].push(BlindingEvaluations {
                        gamma,
                        m_eval,
                        g_hat_evals,
                    });
                }
            }
        }
        debug_assert_eq!(eval_cursor, total_evals);

        // Sample query-batching challenge
        let query_batching_challenge: F = verifier_state.verifier_message();

        // Construct batched eq weights (gammas are shared across polynomials)
        let num_blinding_vars = self.num_blinding_variables();
        let beq_weights = construct_batched_eq_weights(
            &blinding_evals_per_poly[0],
            challenges.masking,
            query_batching_challenge,
            num_blinding_vars,
        );

        // Compute per-polynomial claims and collect evaluations
        // Layout: [m₁_claim, ĝ₁₁_claim, ..., ĝ₁μ_claim, m₂_claim, ĝ₂₁_claim, ..., ĝ₂μ_claim, ...]
        let mut all_evaluations: Vec<F> = Vec::with_capacity(num_polys * (1 + num_witness_vars));
        for poly_idx in 0..num_polys {
            let (m_claim, g_hat_claims) = compute_per_polynomial_claims(
                &blinding_evals_per_poly[poly_idx],
                query_batching_challenge,
            );
            all_evaluations.push(m_claim);
            all_evaluations.extend_from_slice(&g_hat_claims);
        }

        let weight_refs: Vec<&Weights<F>> = vec![&beq_weights];

        // Verify blinding WHIR proof (single batch commitment for all N×(μ+1) blinding polys)
        self.blinding_commitment.verify(
            verifier_state,
            &[blinding_commitment],
            &weight_refs,
            &all_evaluations,
        )?;

        // Reconstruct virtual oracle values from IRS opening + verified blinding evaluations.
        // For N polynomials: compute per-polynomial L_p(γ_j), RLC across polynomials,
        // then fold the combined coset values.
        let num_cols = in_domain_base.num_columns();
        let columns_per_poly = interleaving_depth; // columns per committed polynomial (batch_size=1 for ZK)

        let virtual_oracle_values: Vec<F> = in_domain_base
            .points
            .iter()
            .enumerate()
            .map(|(query_idx, &alpha_base)| {
                let domain_position = query_indices[query_idx];
                let coset_offset = omega_full.pow([domain_position as u64]);
                let coset_offset_ext_inv: F =
                    embedding.map(coset_offset).inverse().unwrap_or(F::ZERO);

                let row = &in_domain_base.matrix[query_idx * num_cols..(query_idx + 1) * num_cols];

                // Compute L_combined(γ_j) = Σ_p α_p · L_p(γ_j) for each coset element j
                let coset_gammas = self.coset_gammas(alpha_base, &omega_powers);
                let combined_coset_values: Vec<F> = coset_gammas
                    .iter()
                    .enumerate()
                    .map(|(coset_elem_idx, &gamma_ext)| {
                        let mut combined_virtual_value = F::ZERO;
                        for poly_idx in 0..num_polys {
                            // f̂_p(γ_j) = Σ_{l=0}^{k-1} embed(row[p*k + l]) · γ^l
                            let f_hat_slice = &row
                                [poly_idx * columns_per_poly..(poly_idx + 1) * columns_per_poly];
                            let f_hat_at_gamma = crate::algebra::mixed_univariate_evaluate(
                                embedding,
                                f_hat_slice,
                                gamma_ext,
                            );

                            // h_p(γ_j) from verified per-polynomial blinding evaluations
                            let blinding_value = blinding_evals_per_poly[poly_idx]
                                [query_idx * interleaving_depth + coset_elem_idx]
                                .compute_h_value(challenges.blinding);

                            // L_p(γ_j) = masking·f̂_p(γ_j) + h_p(γ_j)
                            let virtual_oracle_per_poly =
                                challenges.masking * f_hat_at_gamma + blinding_value;

                            combined_virtual_value += challenges.polynomial_rlc_coeffs[poly_idx]
                                * virtual_oracle_per_poly;
                        }
                        combined_virtual_value
                    })
                    .collect();

                // Fold the interleaving_depth combined coset values
                compute_fold(
                    &combined_coset_values,
                    &folding_randomness.0,
                    coset_offset_ext_inv,
                    zeta_ext_inv,
                    two_inv,
                    fold_factor,
                )
            })
            .collect();

        Ok(virtual_oracle_values)
    }

    /// Verify the final consistency check: compute folding randomness, read deferred
    /// hints, evaluate weight functions, and check the final sumcheck equation.
    fn verify_final_consistency<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        round_constraints: &[(Vec<F>, Vec<Weights<F>>)],
        round_folding_randomness: &[MultilinearPoint<F>],
        final_coefficients: &CoefficientList<F>,
        final_sumcheck_randomness: &MultilinearPoint<F>,
        the_sum: F,
    ) -> VerificationResult<(MultilinearPoint<F>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
    {
        let folding_randomness = MultilinearPoint(
            round_folding_randomness
                .iter()
                .rev()
                .flat_map(|poly| poly.0.iter().copied())
                .collect(),
        );

        let deferred: Vec<F> = verifier_state.prover_hint_ark()?;
        let mut deferred_iter = deferred.iter().copied();
        let mut weight_eval = F::ZERO;

        for (round, (weights_rlc_coeffs, round_weights)) in round_constraints.iter().enumerate() {
            let num_variables = round.checked_sub(1).map_or_else(
                || self.blinded_commitment.initial_num_variables(),
                |prev_round| {
                    self.blinded_commitment.round_configs[prev_round].initial_num_variables()
                },
            );
            let point = MultilinearPoint(folding_randomness.0[..num_variables].to_vec());
            for (rlc_coeff, weight) in zip_strict(weights_rlc_coeffs, round_weights) {
                let eval = if weight.deferred() {
                    let deferred_value = deferred_iter.next();
                    verify!(deferred_value.is_some());
                    deferred_value.unwrap()
                } else {
                    weight.compute(&point)
                };
                weight_eval += *rlc_coeff * eval;
            }
        }
        verify!(deferred_iter.next().is_none());

        let poly_eval = final_coefficients.evaluate(final_sumcheck_randomness);
        verify!(poly_eval * weight_eval == the_sum);

        Ok((folding_randomness, deferred))
    }
}
