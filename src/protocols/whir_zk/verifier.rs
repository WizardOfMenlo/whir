use ark_ff::{FftField, Field};

use super::utils::{
    compute_per_polynomial_claims, construct_batched_eq_weights, IrsDomainParams, ZkParams,
};
use crate::{
    algebra::{
        dot,
        embedding::Embedding,
        polynomials::{CoefficientList, MultilinearPoint},
        Weights,
    },
    hash::Hash,
    protocols::{
        geometric_challenge::geometric_challenge,
        irs_commit,
        whir::{Commitment, Config},
    },
    transcript::{
        codecs::U64, Codec, Decoding, DuplexSpongeInterface, ProverMessage, VerificationResult,
        VerifierMessage, VerifierState,
    },
    utils::zip_strict,
    verify,
};

impl<F: FftField> Config<F> {
    /// Verify a ZK WHIR opening proof.
    ///
    /// This verifies a proof generated by `prove_zk`. The verifier:
    /// 1. Reads blinding evaluations g(āᵢ) and reconstructs modified sums
    /// 2. Runs WHIR rounds, reconstructing virtual oracle values at each initial opening
    /// 3. Verifies helper polynomial evaluations via a nested WHIR proof
    /// 4. Checks the final sumcheck equation
    pub fn verify_zk<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        f_hat_commitments: &[&Commitment<F>],
        helper_commitment: &Commitment<F>,
        helper_config: &Config<F>,
        zk_params: &ZkParams,
        weights: &[&Weights<F>],
        evaluations: &[F],
    ) -> VerificationResult<(MultilinearPoint<F>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        #[cfg(feature = "alloc-track")]
        let mut __snap = crate::alloc_snap!();

        // ====================================================================
        // Phase 1: ZK transcript header — read blinding challenges and build
        //          modified evaluations for P = ρ·f + g
        // ====================================================================
        let num_polys = f_hat_commitments.len();
        let (beta, rho, modified_evaluations) =
            self.read_zk_header(verifier_state, weights, evaluations, num_polys)?;

        let polynomial_rlc_coeffs: Vec<F> =
            geometric_challenge(verifier_state, f_hat_commitments.len());
        let constraint_rlc_coeffs: Vec<F> = geometric_challenge(verifier_state, weights.len());
        let mut round_constraints: Vec<(Vec<F>, Vec<Weights<F>>)> = vec![(
            constraint_rlc_coeffs.clone(),
            weights.iter().map(|&w| w.clone()).collect(),
        )];

        let mut the_sum: F = zip_strict(
            &constraint_rlc_coeffs,
            modified_evaluations.chunks_exact(num_polys),
        )
        .map(|(weight_coeff, row)| *weight_coeff * dot(&polynomial_rlc_coeffs, row))
        .sum();

        let mut round_folding_randomness = Vec::new();

        let folding_randomness = if constraint_rlc_coeffs.is_empty() {
            assert_eq!(the_sum, F::ZERO);
            let fr = verifier_state.verifier_message_vec(self.initial_sumcheck.num_rounds);
            self.initial_sumcheck.round_pow.verify(verifier_state)?;
            MultilinearPoint(fr)
        } else {
            self.initial_sumcheck.verify(verifier_state, &mut the_sum)?
        };
        round_folding_randomness.push(folding_randomness);

        #[cfg(feature = "alloc-track")]
        crate::alloc_report!("verify_zk::phase1_header_initial_sumcheck", __snap);

        // ====================================================================
        // Phase 2: WHIR round loop
        // ====================================================================
        let mut prev_is_initial = true;
        let mut prev_round_commitment: Option<irs_commit::Commitment<F>> = None;

        for (round_index, round_config) in self.round_configs.iter().enumerate() {
            let commitment = round_config
                .irs_committer
                .receive_commitment(verifier_state)?;
            round_config.pow.verify(verifier_state)?;

            let num_variables = round_config.initial_num_variables();

            let (stir_weights, stir_values) = if prev_is_initial {
                self.verify_initial_zk_round(
                    verifier_state,
                    f_hat_commitments,
                    helper_commitment,
                    helper_config,
                    zk_params,
                    rho,
                    beta,
                    &commitment,
                    &round_folding_randomness,
                    num_variables,
                    &polynomial_rlc_coeffs,
                )?
            } else {
                self.verify_subsequent_round(
                    verifier_state,
                    round_index,
                    prev_round_commitment.as_ref().unwrap(),
                    &commitment,
                    &round_folding_randomness,
                    num_variables,
                )?
            };

            let stir_rlc_coeffs = geometric_challenge(verifier_state, stir_weights.len());
            the_sum += dot(&stir_rlc_coeffs, &stir_values);
            round_constraints.push((stir_rlc_coeffs, stir_weights));

            let folding_randomness = round_config.sumcheck.verify(verifier_state, &mut the_sum)?;
            round_folding_randomness.push(folding_randomness);

            prev_is_initial = false;
            prev_round_commitment = Some(commitment);
        }

        #[cfg(feature = "alloc-track")]
        crate::alloc_report!("verify_zk::phase2_whir_rounds", __snap);

        // ====================================================================
        // Phase 3: Final round — read polynomial, verify last commitment
        // ====================================================================
        let final_coefficients = CoefficientList::new(
            verifier_state.prover_messages_vec(self.final_sumcheck.initial_size)?,
        );
        self.final_pow.verify(verifier_state)?;

        self.verify_zk_final_opening(
            verifier_state,
            prev_is_initial,
            f_hat_commitments,
            helper_commitment,
            helper_config,
            zk_params,
            rho,
            beta,
            prev_round_commitment.as_ref(),
            &round_folding_randomness,
            &final_coefficients,
            &polynomial_rlc_coeffs,
        )?;

        #[cfg(feature = "alloc-track")]
        crate::alloc_report!("verify_zk::phase3_final_opening", __snap);

        // ====================================================================
        // Phase 4: Final sumcheck + consistency check
        // ====================================================================
        let final_sumcheck_randomness = self.final_sumcheck.verify(verifier_state, &mut the_sum)?;
        round_folding_randomness.push(final_sumcheck_randomness.clone());

        let result = self.verify_final_consistency(
            verifier_state,
            &round_constraints,
            &round_folding_randomness,
            &final_coefficients,
            &final_sumcheck_randomness,
            the_sum,
        );

        #[cfg(feature = "alloc-track")]
        crate::alloc_report!("verify_zk::phase4_final_sumcheck_consistency", __snap);

        result
    }

    /// Read the ZK transcript header: β, g(āᵢ) evaluations, ρ.
    ///
    /// Returns `(beta, rho, modified_evaluations)` where
    /// modified_evaluations[i] = ρ·evaluations[i] + g_evals[i].
    fn read_zk_header<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        weights: &[&Weights<F>],
        evaluations: &[F],
        num_commitments: usize,
    ) -> VerificationResult<(F, F, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
    {
        let beta: F = verifier_state.verifier_message();
        let g_evals: Vec<F> =
            verifier_state.prover_messages_vec(weights.len() * num_commitments)?;
        let rho: F = verifier_state.verifier_message();

        let modified_evaluations: Vec<F> = zip_strict(evaluations, &g_evals)
            .map(|(&eval, &g_eval)| rho * eval + g_eval)
            .collect();

        Ok((beta, rho, modified_evaluations))
    }

    /// Verify the initial ZK round opening: verify f̂ commitment(s), helper evaluations,
    /// and reconstruct virtual oracle values.
    ///
    /// For N committed polynomials, opens all N f̂ commitments, verifies helper
    /// evaluations for each, and reconstructs combined virtual oracle values using
    /// the polynomial RLC coefficients.
    ///
    /// Returns `(stir_weights, stir_values)`.
    #[allow(clippy::too_many_arguments)]
    fn verify_initial_zk_round<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        f_hat_commitments: &[&Commitment<F>],
        helper_commitment: &Commitment<F>,
        helper_config: &Config<F>,
        zk_params: &ZkParams,
        rho: F,
        beta: F,
        commitment: &irs_commit::Commitment<F>,
        round_folding_randomness: &[MultilinearPoint<F>],
        num_variables: usize,
        polynomial_rlc_coeffs: &[F],
    ) -> VerificationResult<(Vec<Weights<F>>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let num_polys = f_hat_commitments.len();
        let in_domain_base = self
            .initial_committer
            .verify(verifier_state, f_hat_commitments)?;

        let virtual_values = self.verify_zk_helper_evaluations(
            verifier_state,
            &in_domain_base,
            helper_commitment,
            helper_config,
            zk_params,
            rho,
            beta,
            round_folding_randomness.last().unwrap(),
            num_polys,
            polynomial_rlc_coeffs,
        )?;
        let in_domain = in_domain_base.lift(self.embedding());

        let stir_weights: Vec<Weights<F>> = commitment
            .out_of_domain()
            .weights(num_variables)
            .chain(in_domain.weights(num_variables))
            .collect();
        let stir_values: Vec<F> = commitment
            .out_of_domain()
            .values(&[F::ONE])
            .chain(virtual_values)
            .collect();

        Ok((stir_weights, stir_values))
    }

    /// Verify a subsequent (non-initial) round opening.
    ///
    /// Returns `(stir_weights, stir_values)`.
    fn verify_subsequent_round<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        round_index: usize,
        prev_commitment: &irs_commit::Commitment<F>,
        commitment: &irs_commit::Commitment<F>,
        round_folding_randomness: &[MultilinearPoint<F>],
        num_variables: usize,
    ) -> VerificationResult<(Vec<Weights<F>>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let prev_round_config = &self.round_configs[round_index - 1];
        let in_domain = prev_round_config
            .irs_committer
            .verify(verifier_state, &[prev_commitment])?;

        let stir_weights: Vec<Weights<F>> = commitment
            .out_of_domain()
            .weights(num_variables)
            .chain(in_domain.weights(num_variables))
            .collect();
        let stir_values: Vec<F> = commitment
            .out_of_domain()
            .values(&[F::ONE])
            .chain(in_domain.values(&round_folding_randomness.last().unwrap().coeff_weights(true)))
            .collect();

        Ok((stir_weights, stir_values))
    }

    /// Verify the final commitment opening in ZK mode.
    ///
    /// Handles both the case where this is the initial commitment (no intermediate
    /// rounds) and the case where it's the last WHIR round commitment.
    /// For the initial case with N polynomials, opens all N f̂ commitments and
    /// verifies the batched virtual oracle.
    #[allow(clippy::too_many_arguments)]
    fn verify_zk_final_opening<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        prev_is_initial: bool,
        f_hat_commitments: &[&Commitment<F>],
        helper_commitment: &Commitment<F>,
        helper_config: &Config<F>,
        zk_params: &ZkParams,
        rho: F,
        beta: F,
        prev_round_commitment: Option<&irs_commit::Commitment<F>>,
        round_folding_randomness: &[MultilinearPoint<F>],
        final_coefficients: &CoefficientList<F>,
        polynomial_rlc_coeffs: &[F],
    ) -> VerificationResult<()>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        if prev_is_initial {
            let num_polys = f_hat_commitments.len();
            let in_domain_base = self
                .initial_committer
                .verify(verifier_state, f_hat_commitments)?;

            let virtual_values = self.verify_zk_helper_evaluations(
                verifier_state,
                &in_domain_base,
                helper_commitment,
                helper_config,
                zk_params,
                rho,
                beta,
                round_folding_randomness.last().unwrap(),
                num_polys,
                polynomial_rlc_coeffs,
            )?;

            let in_domain = in_domain_base.lift(self.embedding());
            for (weights, value) in zip_strict(
                in_domain.weights(final_coefficients.num_variables()),
                virtual_values,
            ) {
                verify!(weights.evaluate(final_coefficients) == value);
            }
        } else {
            let prev_round_config = self.round_configs.last().unwrap();
            let in_domain = prev_round_config
                .irs_committer
                .verify(verifier_state, &[prev_round_commitment.unwrap()])?;

            for (weights, evals) in zip_strict(
                in_domain.weights(final_coefficients.num_variables()),
                in_domain.values(&round_folding_randomness.last().unwrap().coeff_weights(true)),
            ) {
                verify!(weights.evaluate(final_coefficients) == evals);
            }
        }
        Ok(())
    }

    /// Verify the ZK initial commitment opening.
    ///
    /// Thin wrapper around [`verify_helper_evaluations`] that derives the IRS
    /// domain from this config's initial committer.
    #[allow(clippy::too_many_arguments)]
    fn verify_zk_helper_evaluations<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        in_domain_base: &irs_commit::Evaluations<F::BasePrimeField>,
        helper_commitment: &Commitment<F>,
        helper_config: &Config<F>,
        zk_params: &ZkParams,
        rho: F,
        beta: F,
        folding_randomness: &MultilinearPoint<F>,
        num_polys: usize,
        polynomial_rlc_coeffs: &[F],
    ) -> VerificationResult<Vec<F>>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let domain = IrsDomainParams::<F>::from_config(self);
        verify_helper_evaluations(
            verifier_state,
            &domain,
            in_domain_base,
            helper_commitment,
            helper_config,
            zk_params,
            rho,
            beta,
            folding_randomness,
            num_polys,
            polynomial_rlc_coeffs,
            self.embedding(),
        )
    }
}

/// Verify helper polynomial evaluations for the ZK virtual oracle.
///
/// This is the shared implementation used by both the main ZK verifier
/// (via `Config::verify_zk_helper_evaluations`) and the prefold verifier.
///
/// For N committed polynomials, reads N helper evaluation sets per gamma point,
/// verifies them via a nested WHIR proof, then reconstructs per-polynomial virtual
/// oracle values L_p(γ) and combines them via polynomial RLC.
///
/// Returns the virtual oracle folded values for each query point.
#[allow(clippy::too_many_arguments)]
pub(crate) fn verify_helper_evaluations<F, H, M>(
    verifier_state: &mut VerifierState<'_, H>,
    domain: &IrsDomainParams<F>,
    in_domain_base: &irs_commit::Evaluations<F::BasePrimeField>,
    helper_commitment: &Commitment<F>,
    helper_config: &Config<F>,
    zk_params: &ZkParams,
    rho: F,
    beta: F,
    folding_randomness: &MultilinearPoint<F>,
    num_polys: usize,
    polynomial_rlc_coeffs: &[F],
    embedding: &M,
) -> VerificationResult<Vec<F>>
where
    F: FftField,
    H: DuplexSpongeInterface,
    F: Codec<[H::U]>,
    u8: Decoding<[H::U]>,
    [u8; 32]: Decoding<[H::U]>,
    U64: Codec<[H::U]>,
    Hash: ProverMessage<[H::U]>,
    M: Embedding<Source = F::BasePrimeField, Target = F>,
{
    use super::utils::HelperEvaluations;
    use crate::algebra::polynomials::fold::compute_fold;

    #[cfg(feature = "alloc-track")]
    let mut __snap = crate::alloc_snap!();

    let mu = zk_params.mu;
    let k = domain.k;
    let fold_factor = k.trailing_zeros() as usize; // log2(k)

    // Precompute inverses for compute_fold (lifted to extension field)
    let zeta_ext_inv: F = embedding
        .map(domain.zeta)
        .inverse()
        .expect("coset generator invertible");
    let two_inv = F::from(2u64).inverse().expect("char ≠ 2");

    // Read ALL helper evaluations from transcript in one batch.
    // Prover sends: for each gamma, for each polynomial p:
    //   m_eval_p, ĝ₁(pow(γ))_p, ..., ĝμ(pow(γ))_p
    let q = in_domain_base.points.len();
    let evals_per_point = 1 + mu; // m_eval + mu g_hat_evals
    let num_gammas = q * k;
    let total_evals = num_gammas * num_polys * evals_per_point;
    let all_evals: Vec<F> = verifier_state.read_prover_messages_bytes(total_evals)?;

    // Parse the flat eval vector into per-polynomial HelperEvaluations.
    let mut helper_evals_per_poly: Vec<Vec<HelperEvaluations<F>>> = (0..num_polys)
        .map(|_| Vec::with_capacity(num_gammas))
        .collect();
    let mut query_indices: Vec<usize> = Vec::with_capacity(q);
    let mut eval_cursor = 0;

    for &alpha_base in &in_domain_base.points {
        let idx = domain.query_index(alpha_base);
        query_indices.push(idx);
        let coset_gammas = domain.coset_gammas(alpha_base, embedding);

        for gamma in coset_gammas {
            for p in 0..num_polys {
                let m_eval = all_evals[eval_cursor];
                eval_cursor += 1;
                let g_hat_evals = all_evals[eval_cursor..eval_cursor + mu].to_vec();
                eval_cursor += mu;
                helper_evals_per_poly[p].push(HelperEvaluations {
                    gamma,
                    m_eval,
                    g_hat_evals,
                });
            }
        }
    }
    debug_assert_eq!(eval_cursor, total_evals);

    #[cfg(feature = "alloc-track")]
    crate::alloc_report!("  verify_helper::read_transcript", __snap);

    // Sample τ₂ (query-batching challenge)
    let tau2: F = verifier_state.verifier_message();

    // Construct batched eq weights (gammas are shared across polynomials)
    let beq_weights =
        construct_batched_eq_weights(&helper_evals_per_poly[0], rho, tau2, zk_params.ell);

    // Compute per-polynomial claims and collect evaluations
    // Layout: [m₁_claim, ĝ₁₁_claim, ..., ĝ₁μ_claim, m₂_claim, ĝ₂₁_claim, ..., ĝ₂μ_claim, ...]
    let mut all_evaluations: Vec<F> = Vec::with_capacity(num_polys * (1 + mu));
    for p in 0..num_polys {
        let (m_claim, g_hat_claims) =
            compute_per_polynomial_claims(&helper_evals_per_poly[p], tau2);
        all_evaluations.push(m_claim);
        all_evaluations.extend_from_slice(&g_hat_claims);
    }

    let weight_refs: Vec<&Weights<F>> = vec![&beq_weights];

    #[cfg(feature = "alloc-track")]
    crate::alloc_report!("  verify_helper::build_weights_claims", __snap);

    // Verify helper WHIR proof (single batch commitment for all N×(μ+1) helper polys)
    helper_config.verify(
        verifier_state,
        &[helper_commitment],
        &weight_refs,
        &all_evaluations,
    )?;

    #[cfg(feature = "alloc-track")]
    crate::alloc_report!("  verify_helper::helper_whir_verify", __snap);

    // Reconstruct virtual oracle values from IRS opening + verified helper evaluations.
    // For N polynomials: compute per-polynomial L_p(γ_j), RLC across polynomials,
    // then fold the combined coset values.
    let num_cols = in_domain_base.num_columns();
    let k_per_poly = k; // columns per committed polynomial (batch_size=1 for ZK)

    let virtual_values: Vec<F> = in_domain_base
        .points
        .iter()
        .enumerate()
        .map(|(qi, &alpha_base)| {
            let idx = query_indices[qi];
            let coset_offset = domain.omega_full.pow([idx as u64]);
            let coset_offset_ext_inv: F = embedding.map(coset_offset).inverse().unwrap_or(F::ZERO);

            let row = &in_domain_base.matrix[qi * num_cols..(qi + 1) * num_cols];

            // Compute L_combined(γ_j) = Σ_p α_p · L_p(γ_j) for each coset element j
            let coset_gammas = domain.coset_gammas(alpha_base, embedding);
            let l_coset_values: Vec<F> = coset_gammas
                .iter()
                .enumerate()
                .map(|(j, &gamma_ext)| {
                    let mut l_combined = F::ZERO;
                    for p in 0..num_polys {
                        // f̂_p(γ_j) = Σ_{l=0}^{k-1} embed(row[p*k + l]) · γ^l
                        let f_hat_slice = &row[p * k_per_poly..(p + 1) * k_per_poly];
                        let f_hat_p_at_gamma = crate::algebra::mixed_univariate_evaluate(
                            embedding,
                            f_hat_slice,
                            gamma_ext,
                        );

                        // h_p(γ_j) from verified per-polynomial helper evaluations
                        let h_p_at_gamma =
                            helper_evals_per_poly[p][qi * k + j].compute_h_value(beta);

                        // L_p(γ_j) = ρ·f̂_p(γ_j) + h_p(γ_j)
                        let l_p = rho * f_hat_p_at_gamma + h_p_at_gamma;

                        l_combined += polynomial_rlc_coeffs[p] * l_p;
                    }
                    l_combined
                })
                .collect();

            // Fold the k combined coset values
            compute_fold(
                &l_coset_values,
                &folding_randomness.0,
                coset_offset_ext_inv,
                zeta_ext_inv,
                two_inv,
                fold_factor,
            )
        })
        .collect();

    #[cfg(feature = "alloc-track")]
    crate::alloc_report!("  verify_helper::reconstruct_virtual_oracle", __snap);

    Ok(virtual_values)
}
