use ark_ff::FftField;

use super::{config::Config, Commitment};
use crate::{
    algebra::{
        dot,
        embedding::Identity,
        linear_form::{Evaluate, LinearForm, MultilinearEvaluation},
        polynomials::MultilinearPoint,
        tensor_product,
    },
    hash::Hash,
    protocols::{geometric_challenge::geometric_challenge, irs_commit},
    transcript::{
        codecs::U64, Codec, Decoding, DuplexSpongeInterface, ProverMessage, VerificationResult,
        VerifierMessage, VerifierState,
    },
    utils::zip_strict,
    verify,
};

enum RoundCommitment<'a, F: FftField> {
    Initial {
        commitments: &'a [&'a irs_commit::Commitment<F>],
        batching_weights: Vec<F>,
    },
    Round {
        commitment: irs_commit::Commitment<F>,
    },
}

impl<F: FftField> Config<F> {
    /// Verify a batched WHIR proof for multiple commitments.
    ///
    /// This verifies a batch proof generated by `prove_batch`. The verifier reads the N×M
    /// constraint evaluation matrix from the transcript, samples the batching randomness γ,
    /// and reconstructs the combined constraints using RLC. Round 0 verifies openings in all
    /// N original commitment trees, while subsequent rounds verify the single batched polynomial.
    ///
    /// Returns the constraint evaluation point and values of deferred constraints.
    #[allow(clippy::too_many_lines)]
    pub fn verify<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        commitments: &[&Commitment<F>],
        weights: &[&dyn LinearForm<F>],
        evaluations: &[F],
    ) -> VerificationResult<(MultilinearPoint<F>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let num_polynomials = commitments.len() * self.initial_committer.num_polynomials;
        verify!(weights.len() * num_polynomials == evaluations.len());
        if num_polynomials == 0 {
            return Ok((MultilinearPoint::default(), Vec::new()));
        }

        // Complete the constraint and evaluation matrix with OODs and their cross-terms.
        let (oods_weights, oods_matrix) = {
            let mut oods_weights = Vec::new();
            let mut oods_matrix = Vec::new();

            // OOD weights from each commitment, evaluated for each polynomial
            let mut polynomial_offset = 0;
            for commitment in commitments {
                for (weights, oods_row) in zip_strict(
                    commitment.out_of_domain().evaluators(self.initial_size()),
                    commitment.out_of_domain().rows(),
                ) {
                    for j in 0..num_polynomials {
                        if j >= polynomial_offset && j < oods_row.len() + polynomial_offset {
                            oods_matrix.push(oods_row[j - polynomial_offset]);
                        } else {
                            oods_matrix.push(verifier_state.prover_message()?);
                        }
                    }
                    oods_weights.push(weights);
                }
                polynomial_offset += commitment.num_polynomials();
            }
            (oods_weights, oods_matrix)
        };

        // Random linear combination of the polynomials.
        let polynomial_rlc_coeffs = geometric_challenge(verifier_state, num_polynomials);
        let mut prev_commitment = RoundCommitment::Initial {
            commitments,
            batching_weights: polynomial_rlc_coeffs.clone(),
        };

        // Random linear combination of the constraints.
        let constraint_rlc_coeffs: Vec<F> =
            geometric_challenge(verifier_state, oods_weights.len() + weights.len());
        let initial_weight_rlc_coeffs = constraint_rlc_coeffs[oods_weights.len()..].to_vec();
        let oods_rlc_coeffs = constraint_rlc_coeffs[..oods_weights.len()].to_vec();

        // Compute "The Sum"
        let mut the_sum = zip_strict(
            &initial_weight_rlc_coeffs,
            evaluations.chunks_exact(num_polynomials),
        )
        .map(|(poly_coeff, row)| *poly_coeff * dot(&polynomial_rlc_coeffs, row))
        .sum::<F>();
        the_sum += zip_strict(&oods_rlc_coeffs, oods_matrix.chunks_exact(num_polynomials))
            .map(|(poly_coeff, row)| *poly_coeff * dot(&polynomial_rlc_coeffs, row))
            .sum::<F>();
        let mut round_constraints = vec![(oods_rlc_coeffs, oods_weights)];

        let mut round_folding_randomness = Vec::new();

        // Run initial sumcheck on batched polynomial with combined statement
        let folding_randomness = if constraint_rlc_coeffs.is_empty() {
            // There are no constraints yet, so we can skip the sumcheck.
            // (If we did run it, all sumcheck polynomials would be constant zero)
            assert_eq!(the_sum, F::ZERO);
            let folding_randomness =
                verifier_state.verifier_message_vec(self.initial_sumcheck.num_rounds);
            self.initial_sumcheck.round_pow.verify(verifier_state)?;
            MultilinearPoint(folding_randomness)
        } else {
            self.initial_sumcheck.verify(verifier_state, &mut the_sum)?
        };
        round_folding_randomness.push(folding_randomness);

        for (round_index, round_config) in self.round_configs.iter().enumerate() {
            // Receive commitment to the folded polynomial, plus out-of-domain constraints
            let commitment = round_config
                .irs_committer
                .receive_commitment(verifier_state)?;

            // Proof of work before in-domain challenges
            round_config.pow.verify(verifier_state)?;

            // Open the previous round's commitment, producing in-domain evaluations.
            let (in_domain, poly_rlc) = match prev_commitment {
                RoundCommitment::Initial {
                    commitments,
                    batching_weights,
                } => {
                    let in_domain = self.initial_committer.verify(verifier_state, commitments)?;
                    // TODO: Skip lift and keep initial in-domain in subfield for evaluation.
                    // This should be every so slightly more performant.
                    (in_domain.lift(self.embedding()), batching_weights)
                }
                RoundCommitment::Round { commitment } => {
                    let prev_round_config = &self.round_configs[round_index - 1];
                    let in_domain = prev_round_config
                        .irs_committer
                        .verify(verifier_state, &[&commitment])?;
                    (in_domain, vec![F::ONE])
                }
            };

            // Random linear combination of out- and in-domain constraints
            let constraint_weights = commitment
                .out_of_domain()
                .evaluators(round_config.initial_size())
                .chain(in_domain.evaluators(round_config.initial_size()))
                .collect::<Vec<_>>();
            let constraint_values = commitment
                .out_of_domain()
                .values(&[F::ONE])
                .chain(in_domain.values(&tensor_product(
                    &poly_rlc,
                    &round_folding_randomness.last().unwrap().coeff_weights(true),
                )))
                .collect::<Vec<_>>();
            let constraint_rlc_coeffs =
                geometric_challenge(verifier_state, constraint_values.len());
            the_sum += dot(&constraint_rlc_coeffs, &constraint_values);
            round_constraints.push((constraint_rlc_coeffs, constraint_weights));

            // Sumcheck round
            let folding_randomness = round_config.sumcheck.verify(verifier_state, &mut the_sum)?;
            round_folding_randomness.push(folding_randomness);

            prev_commitment = RoundCommitment::Round { commitment };
        }

        // Final round (we receive the full polynomial instead of a commitment)
        let final_coefficients =
            verifier_state.prover_messages_vec(self.final_sumcheck.initial_size)?;

        // Final proof of work.
        self.final_pow.verify(verifier_state)?;

        // Open previous witness, as usual
        let (in_domain, poly_rlc) = match prev_commitment {
            RoundCommitment::Initial {
                commitments,
                batching_weights,
            } => {
                let in_domain = self.initial_committer.verify(verifier_state, commitments)?;
                (in_domain.lift(self.embedding()), batching_weights)
            }
            RoundCommitment::Round { commitment } => {
                let prev_round_config = &self.round_configs.last().unwrap();
                let in_domain = prev_round_config
                    .irs_committer
                    .verify(verifier_state, &[&commitment])?;
                (in_domain, vec![F::ONE])
            }
        };

        // Verify in-domain constraints directly
        for (weights, evals) in zip_strict(
            in_domain.evaluators(final_coefficients.len()),
            in_domain.values(&tensor_product(
                &poly_rlc,
                &MultilinearPoint(
                    round_folding_randomness
                        .last()
                        .unwrap()
                        .0
                        .iter()
                        .rev()
                        .copied()
                        .collect(),
                )
                .coeff_weights(false),
            )),
        ) {
            verify!(weights.evaluate_coeffs(&Identity::<F>::new(), &final_coefficients) == evals);
        }

        // Final sumcheck
        let final_sumcheck_randomness = self.final_sumcheck.verify(verifier_state, &mut the_sum)?;
        round_folding_randomness.push(final_sumcheck_randomness.clone());

        // Compute folding randomness across all rounds
        let folding_randomness = MultilinearPoint(
            round_folding_randomness
                .into_iter()
                .flat_map(|poly| poly.0.into_iter())
                .collect(),
        );

        // Evaluate all round constraints weights
        let mut weight_eval = F::ZERO;
        for (round, (weights_rlc_coeffs, weights)) in round_constraints.into_iter().enumerate() {
            let num_variables = round.checked_sub(1).map_or_else(
                || self.initial_num_variables(),
                |p| self.round_configs[p].initial_num_variables(),
            );
            let start = folding_randomness.0.len().saturating_sub(num_variables);
            for (rlc_coeff, weights) in zip_strict(weights_rlc_coeffs, weights) {
                weight_eval += rlc_coeff * weights.mle_evaluate(&folding_randomness.0[start..]);
            }
        }

        // Compute evaluation of non-deferred initial weights in folding randomness point
        let deferred: Vec<F> = verifier_state.prover_hint_ark()?;
        let mut deferred_iter = deferred.iter().copied();
        for (rlc_coeff, weights) in zip_strict(initial_weight_rlc_coeffs, weights) {
            let eval = if weights.deferred() {
                let deferred = deferred_iter.next();
                verify!(deferred.is_some());
                deferred.unwrap()
            } else {
                weights.mle_evaluate(&folding_randomness.0)
            };
            weight_eval += rlc_coeff * eval;
        }
        verify!(deferred_iter.next().is_none());

        // Check the final sumcheck equation
        let poly_eval = MultilinearEvaluation::new(final_sumcheck_randomness.0)
            .evaluate_coeffs(&Identity::new(), &final_coefficients);
        verify!(poly_eval * weight_eval == the_sum);

        // Return the evaluation point and the claimed values of the deferred weights.
        Ok((folding_randomness, deferred))
    }
}
