use ark_ff::FftField;

use super::{
    config::WhirConfig,
    statement::{Constraint, Weights},
};
use crate::{
    algebra::{
        embedding,
        ntt::transpose,
        poly_utils::{coeffs::CoefficientList, multilinear::MultilinearPoint},
        tensor_product,
    },
    hash::Hash,
    protocols::{geometric_challenge::geometric_challenge, irs_commit},
    transcript::{
        codecs::U64, Codec, Decoding, DuplexSpongeInterface, ProverMessage, VerificationResult,
        VerifierMessage, VerifierState,
    },
    utils::{expand_randomness, zip_strict},
    verify,
    whir::{config::InitialSumcheck, Commitment},
};

pub(crate) enum RoundCommitment<'a, F: FftField> {
    Initial {
        commitments: &'a [&'a irs_commit::Commitment<F>],
        batching_weights: Vec<F>,
    },
    Round {
        commitment: irs_commit::Commitment<F>,
    },
}

impl<F: FftField> WhirConfig<F> {
    /// Verify a batched WHIR proof for multiple commitments.
    ///
    /// This verifies a batch proof generated by `prove_batch`. The verifier reads the N×M
    /// constraint evaluation matrix from the transcript, samples the batching randomness γ,
    /// and reconstructs the combined constraints using RLC. Round 0 verifies openings in all
    /// N original commitment trees, while subsequent rounds verify the single batched polynomial.
    ///
    /// Returns the constraint evaluation point and values of deferred constraints.
    #[allow(clippy::too_many_lines)]
    pub fn verify<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        commitments: &[&Commitment<F>],
        weights: &[&Weights<F>],
        evaluations: &[F],
    ) -> VerificationResult<(MultilinearPoint<F>, Vec<F>)>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        let num_polynomials = commitments.len() * self.initial_committer.num_polynomials;
        verify!(weights.len() * num_polynomials == evaluations.len());
        if num_polynomials == 0 {
            return Ok((MultilinearPoint::default(), Vec::new()));
        }
        let embedding = self.initial_committer.embedding();

        // Complete the constraint and evaluation matrix with OODs and their cross-terms.
        let (constraint_weights, constraints_matrix) = {
            let mut all_weights = Vec::new();
            let mut matrix = Vec::new();

            // OOD weights from each commitment, evaluated for each polynomial
            let mut polynomial_offset = 0;
            for commitment in commitments {
                for (weights, oods_row) in zip_strict(
                    commitment
                        .out_of_domain()
                        .weights(self.initial_num_variables()),
                    commitment.out_of_domain().rows(),
                ) {
                    for j in 0..num_polynomials {
                        if j >= polynomial_offset && j < oods_row.len() + polynomial_offset {
                            matrix.push(oods_row[j - polynomial_offset]);
                        } else {
                            matrix.push(verifier_state.prover_message()?);
                        }
                    }
                    all_weights.push(weights);
                }
                polynomial_offset += commitment.num_polynomials();
            }

            all_weights.extend(weights.iter().map(|&w| w.clone()));
            matrix.extend_from_slice(evaluations);
            (all_weights, matrix)
        };
        let num_constraints = constraint_weights.len();
        let mut constraint_evals_matrix = constraints_matrix;

        transpose(
            constraint_evals_matrix.as_mut_slice(),
            num_constraints,
            num_polynomials,
        );

        // Reinterpret as rows for easier indexing: rows = num_polynomials, cols = num_constraints
        let constraint_evals_matrix: Vec<&[F]> = constraint_evals_matrix
            .chunks_exact(num_constraints)
            .collect();

        // Step 2: Sample batching randomness γ (cryptographically bound to matrix)
        let batching_weights = geometric_challenge(verifier_state, num_polynomials);

        let mut prev_commitment = RoundCommitment::Initial {
            commitments,
            batching_weights: batching_weights.clone(),
        };

        let mut round_constraints = Vec::new();
        let mut round_folding_randomness = Vec::new();
        let mut claimed_sum = F::ZERO;

        // Step 3: Reconstruct combined constraints using RLC of the evaluation matrix
        // For each constraint j: combined_eval[j] = Σᵢ γⁱ·eval[i][j]
        //
        match &self.initial_sumcheck {
            InitialSumcheck::Full(config) => {
                let mut all_constraints = Vec::new();

                for (constraint_idx, weights) in constraint_weights.iter().enumerate() {
                    let mut combined_eval = F::ZERO;
                    for (row, weight) in batching_weights.iter().enumerate() {
                        combined_eval += *weight * constraint_evals_matrix[row][constraint_idx];
                    }

                    all_constraints.push(Constraint {
                        weights: weights.clone(),
                        sum: combined_eval,
                        defer_evaluation: weights.deffered(),
                    });
                }

                let combination_randomness =
                    self.combine_constraints(verifier_state, &mut claimed_sum, &all_constraints)?;
                round_constraints.push((combination_randomness, all_constraints));

                // Initial sumcheck on the combined constraints
                let folding_randomness = config.verify(verifier_state, &mut claimed_sum)?;
                round_folding_randomness.push(folding_randomness);
            }
            InitialSumcheck::Abridged { folding_size, pow } => {
                for commitment in commitments {
                    assert_eq!(commitment.out_of_domain().points.len(), 0);
                }
                round_constraints.push((vec![], vec![]));

                let mut folding_randomness = vec![F::ZERO; *folding_size];
                for randomness in &mut folding_randomness {
                    *randomness = verifier_state.verifier_message();
                }
                round_folding_randomness.push(MultilinearPoint(folding_randomness));

                pow.verify(verifier_state)?;
            }
        };
        for (round_index, round_config) in self.round_configs.iter().enumerate() {
            let commitment = round_config
                .irs_committer
                .receive_commitment(verifier_state)?;

            let oods_constraints = commitment.out_of_domain().constraints(
                &embedding::Identity::new(),
                &[F::ONE],
                round_config.initial_num_variables(),
            );

            round_config.pow.verify(verifier_state)?;

            let in_domain_constraints = match prev_commitment {
                RoundCommitment::Initial {
                    commitments,
                    batching_weights,
                } => {
                    let in_domain = self.initial_committer.verify(verifier_state, commitments)?;
                    let weights = tensor_product(
                        &batching_weights,
                        &round_folding_randomness.last().unwrap().coeff_weights(true),
                    );
                    in_domain.constraints(embedding, &weights, round_config.initial_num_variables())
                }
                RoundCommitment::Round { commitment } => {
                    let prev_round_config = &self.round_configs[round_index - 1];
                    let in_domain = prev_round_config
                        .irs_committer
                        .verify(verifier_state, &[&commitment])?;
                    let weights = round_folding_randomness.last().unwrap().coeff_weights(true);
                    in_domain.constraints(
                        &embedding::Identity::new(),
                        &weights,
                        round_config.initial_num_variables(),
                    )
                }
            };

            let constraints: Vec<Constraint<F>> = oods_constraints
                .into_iter()
                .chain(in_domain_constraints.into_iter())
                .collect();
            let combination_randomness =
                self.combine_constraints(verifier_state, &mut claimed_sum, &constraints)?;
            round_constraints.push((combination_randomness.clone(), constraints));

            let folding_randomness = round_config
                .sumcheck
                .verify(verifier_state, &mut claimed_sum)?;
            round_folding_randomness.push(folding_randomness);

            prev_commitment = RoundCommitment::Round { commitment };
        }

        // Final round (same as regular verify)
        let mut final_coefficients = vec![F::ZERO; self.final_sumcheck.initial_size];
        for coeff in &mut final_coefficients {
            *coeff = verifier_state.prover_message()?;
        }
        let final_coefficients = CoefficientList::new(final_coefficients);

        self.final_pow.verify(verifier_state)?;

        let in_domain_constraints = match prev_commitment {
            RoundCommitment::Initial {
                commitments,
                batching_weights,
            } => {
                let in_domain = self.initial_committer.verify(verifier_state, commitments)?;
                let weights = tensor_product(
                    &batching_weights,
                    &round_folding_randomness.last().unwrap().coeff_weights(true),
                );
                let final_num_variables = self.final_sumcheck.initial_size.ilog2() as usize;
                in_domain.constraints(embedding, &weights, final_num_variables)
            }
            RoundCommitment::Round { commitment } => {
                let prev_round_config = self.round_configs.last().unwrap();
                let in_domain = prev_round_config
                    .irs_committer
                    .verify(verifier_state, &[&commitment])?;
                let weights = round_folding_randomness.last().unwrap().coeff_weights(true);
                in_domain.constraints(
                    &embedding::Identity::new(),
                    &weights,
                    prev_round_config.initial_num_variables()
                        - prev_round_config.sumcheck.num_rounds(),
                )
            }
        };

        verify!(in_domain_constraints
            .iter()
            .all(|c| c.verify(&final_coefficients)));

        let final_sumcheck_randomness = self
            .final_sumcheck
            .verify(verifier_state, &mut claimed_sum)?;
        round_folding_randomness.push(final_sumcheck_randomness.clone());

        // Compute folding randomness across all rounds
        let folding_randomness = MultilinearPoint(
            round_folding_randomness
                .into_iter()
                .rev()
                .flat_map(|poly| poly.0.into_iter())
                .collect(),
        );

        // Compute evaluation of weights in folding randomness
        let deferred: Vec<F> = verifier_state.prover_hint_ark()?;
        let evaluation_of_weights =
            self.eval_constraints_poly(&round_constraints, &deferred, folding_randomness.clone());

        // Check the final sumcheck evaluation
        let final_value = final_coefficients.evaluate(&final_sumcheck_randomness);
        verify!(claimed_sum == evaluation_of_weights * final_value);

        Ok((folding_randomness, deferred))
    }

    /// Create a random linear combination of constraints and add it to the claim.
    /// Returns the randomness used.
    pub fn combine_constraints<H>(
        &self,
        verifier_state: &mut VerifierState<'_, H>,
        claimed_sum: &mut F,
        constraints: &[Constraint<F>],
    ) -> VerificationResult<Vec<F>>
    where
        H: DuplexSpongeInterface,
        F: Codec<[H::U]>,
        u8: Decoding<[H::U]>,
        [u8; 32]: Decoding<[H::U]>,
        U64: Codec<[H::U]>,
        Hash: ProverMessage<[H::U]>,
    {
        assert!(constraints
            .windows(2)
            .all(|w| w[0].weights.num_variables() == w[1].weights.num_variables()));

        let combination_randomness_gen = if constraints.len() > 1 {
            verifier_state.verifier_message()
        } else {
            F::ONE
        };
        let combination_randomness =
            expand_randomness(combination_randomness_gen, constraints.len());
        *claimed_sum += zip_strict(constraints.iter(), &combination_randomness)
            .map(|(c, rand)| c.sum * rand)
            .sum::<F>();

        Ok(combination_randomness)
    }

    /// Evaluate the random linear combination of constraints in `point`.
    fn eval_constraints_poly(
        &self,
        constraints: &[(Vec<F>, Vec<Constraint<F>>)],
        deferred: &[F],
        mut point: MultilinearPoint<F>,
    ) -> F {
        let mut deferred = deferred.iter().copied();
        let mut value = F::ZERO;

        for (round, (randomness, constraints)) in constraints.iter().enumerate() {
            assert_eq!(randomness.len(), constraints.len());
            let num_variables = round.checked_sub(1).map_or_else(
                || self.initial_size().ilog2() as usize,
                |p| self.round_configs[p].initial_num_variables(),
            );
            point = MultilinearPoint(point.0[..num_variables].to_vec());
            value += zip_strict(constraints.iter(), randomness)
                .map(|(constraint, &randomness)| {
                    let value = if constraint.defer_evaluation {
                        deferred.next().unwrap()
                    } else {
                        constraint.weights.compute(&point)
                    };
                    value * randomness
                })
                .sum::<F>();
        }
        value
    }
}
